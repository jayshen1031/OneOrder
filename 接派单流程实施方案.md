# OneOrder接派单流程实施方案

## 1. 需求分析

### 1.1 业务流程概述
实现完整的客服接单→派单→操作接单→协议确认的业务流程，支持：
- 客服作为订单负责人接单
- 多服务项的灵活派单  
- 内部协议的智能匹配和确认
- 操作人员的主动接单确认
- 基于协议的分润计算准备

### 1.2 核心业务规则
1. **订单负责制**: 客服创建订单后自动成为订单负责人
2. **服务派单制**: 每个服务必须指派给具体操作人员
3. **协议确认制**: 操作人员接单时必须确认内部协议
4. **分润依据制**: 协议确认后才能进行分润计算

## 2. 现有系统分析

### 2.1 已有功能模块
✅ **订单管理**: 完整的订单CRUD和状态管理
✅ **清分引擎**: 星式/链式清分和验证机制  
✅ **内部协议**: 协议匹配和管理功能
✅ **员工管理**: Staff实体和部门权限管理
✅ **服务配置**: 188个费用科目的完整配置

### 2.2 需要增强的模块
🔧 **用户角色**: 区分客服(CUSTOMER_SERVICE)和操作(OPERATION)角色
🔧 **派单工作流**: OrderService实体增加派单状态管理
🔧 **消息通知**: 派单通知和接单确认机制
🔧 **权限控制**: 基于角色的功能权限管理

## 3. 数据模型设计

### 3.1 用户角色枚举增强

```java
// Staff.java - 增加角色类型
public enum RoleType {
    CUSTOMER_SERVICE("客服"),      // 新增：客服角色
    OPERATION("操作人员"),         // 现有：操作人员
    MANAGER("主管"),              // 现有：主管
    ADMIN("管理员")               // 现有：管理员
}
```

### 3.2 订单服务状态优化

```java
// OrderService.java - 优化服务状态
public enum ServiceStatus {
    PENDING("待派单"),            // 服务已选择，待客服派单
    ASSIGNED("已派单"),           // 客服已派单，待操作人员接单
    PROTOCOL_CONFIRMED("协议已确认"), // 操作人员已接单并确认协议
    IN_PROGRESS("执行中"),        // 操作人员开始执行服务
    COMPLETED("已完成"),          // 服务执行完成
    BLOCKED("受阻")              // 执行过程中遇到问题
}
```

### 3.3 新增派单通知实体

```java
@Entity
@Table(name = "service_assignment_notification")
public class ServiceAssignmentNotification {
    private Long notificationId;
    private String orderId;
    private Long serviceId;
    private String fromStaffId;      // 派单人(客服)
    private String toStaffId;        // 被派单人(操作)
    private String protocolId;       // 选定的内部协议
    private String message;          // 派单说明
    private NotificationStatus status; // 通知状态
    private LocalDateTime sentTime;  // 发送时间
    private LocalDateTime readTime;  // 阅读时间
    private LocalDateTime confirmedTime; // 确认时间
}
```

## 4. 功能实现方案

### 4.1 客服接单功能

#### 4.1.1 增强订单创建接口
```java
@PostMapping("/orders/create-with-services")
public ResponseEntity<OrderCreationResponse> createOrderWithServices(
    @RequestBody OrderCreationRequest request) {
    
    // 1. 验证客服权限
    Staff customerService = validateCustomerServiceRole(request.getCustomerServiceId());
    
    // 2. 创建订单
    Order order = createOrder(request);
    order.setResponsibleStaffId(request.getCustomerServiceId()); // 客服成为负责人
    
    // 3. 根据业务类型加载可选服务
    List<ServiceConfig> availableServices = 
        serviceConfigService.getServicesByBusinessType(request.getBusinessType());
    
    // 4. 创建选定的服务项
    for (String serviceCode : request.getSelectedServices()) {
        OrderService orderService = new OrderService();
        orderService.setOrderId(order.getOrderId());
        orderService.setServiceCode(serviceCode);
        orderService.setStatus(ServiceStatus.PENDING); // 待派单状态
        orderService.setCreatedBy(request.getCustomerServiceId());
        orderServiceRepository.save(orderService);
    }
    
    return ResponseEntity.ok(new OrderCreationResponse(order, availableServices));
}
```

#### 4.1.2 服务选择界面优化
```javascript
// 根据业务类型动态加载服务选项
function loadServiceOptions(businessType) {
    fetch(`/api/services/available?businessType=${businessType}`)
    .then(response => response.json())
    .then(services => {
        displayServiceSelection(services);
    });
}

// 显示服务选择界面
function displayServiceSelection(services) {
    const container = document.getElementById('serviceSelection');
    container.innerHTML = services.map(service => `
        <div class="form-check">
            <input class="form-check-input" type="checkbox" 
                   value="${service.serviceCode}" id="service_${service.serviceCode}">
            <label class="form-check-label" for="service_${service.serviceCode}">
                ${service.serviceName} - ${service.description}
                <small class="text-muted">(${service.priceRange})</small>
            </label>
        </div>
    `).join('');
}
```

### 4.2 服务派单功能

#### 4.2.1 派单界面设计
```html
<!-- 服务派单界面 -->
<div class="card">
    <div class="card-header">
        <h5><i class="fas fa-tasks me-2"></i>服务派单 - 订单 ${orderId}</h5>
    </div>
    <div class="card-body">
        <div id="servicesToAssign">
            <!-- 动态加载待派单服务 -->
        </div>
    </div>
</div>

<!-- 单个服务派单项 -->
<div class="service-assignment-item mb-3">
    <div class="row align-items-center">
        <div class="col-md-3">
            <strong>${serviceName}</strong>
            <small class="d-block text-muted">${serviceCode}</small>
        </div>
        <div class="col-md-3">
            <select class="form-select" id="staff_${serviceId}" onchange="loadProtocolsForStaff(${serviceId})">
                <option value="">选择操作人员...</option>
                <!-- 动态加载操作人员 -->
            </select>
        </div>
        <div class="col-md-4">
            <select class="form-select" id="protocol_${serviceId}">
                <option value="">选择内部协议...</option>
                <!-- 基于操作人员动态加载协议 -->
            </select>
        </div>
        <div class="col-md-2">
            <button class="btn btn-primary" onclick="assignService(${serviceId})">
                <i class="fas fa-paper-plane me-1"></i>派单
            </button>
        </div>
    </div>
</div>
```

#### 4.2.2 协议匹配逻辑
```java
@PostMapping("/services/{serviceId}/assign")
public ResponseEntity<AssignmentResponse> assignService(
    @PathVariable Long serviceId,
    @RequestBody ServiceAssignmentRequest request) {
    
    // 1. 验证客服权限和订单负责关系
    OrderService orderService = orderServiceRepository.findById(serviceId)
        .orElseThrow(() -> new EntityNotFoundException("服务不存在"));
    
    Order order = orderRepository.findById(orderService.getOrderId())
        .orElseThrow(() -> new EntityNotFoundException("订单不存在"));
    
    if (!order.getResponsibleStaffId().equals(request.getCustomerServiceId())) {
        throw new UnauthorizedException("只有订单负责人才能派单");
    }
    
    // 2. 验证操作人员权限
    Staff operationStaff = staffRepository.findById(request.getOperationStaffId())
        .orElseThrow(() -> new EntityNotFoundException("操作人员不存在"));
    
    if (!RoleType.OPERATION.equals(operationStaff.getRoleType())) {
        throw new InvalidRoleException("只能派单给操作人员");
    }
    
    // 3. 验证协议有效性
    InternalProtocol protocol = internalProtocolRepository.findById(request.getProtocolId())
        .orElseThrow(() -> new EntityNotFoundException("内部协议不存在"));
    
    if (!protocol.getActive() || !isProtocolApplicable(protocol, orderService, operationStaff)) {
        throw new InvalidProtocolException("协议不适用于当前服务和操作人员");
    }
    
    // 4. 更新服务派单信息
    orderService.setOperationStaffId(request.getOperationStaffId());
    orderService.setOperationDepartmentId(operationStaff.getDepartmentId());
    orderService.setInternalProtocolId(request.getProtocolId());
    orderService.setStatus(ServiceStatus.ASSIGNED);
    orderService.setAssignedTime(LocalDateTime.now());
    orderService.setAssignedBy(request.getCustomerServiceId());
    orderServiceRepository.save(orderService);
    
    // 5. 创建派单通知
    ServiceAssignmentNotification notification = new ServiceAssignmentNotification();
    notification.setOrderId(orderService.getOrderId());
    notification.setServiceId(serviceId);
    notification.setFromStaffId(request.getCustomerServiceId());
    notification.setToStaffId(request.getOperationStaffId());
    notification.setProtocolId(request.getProtocolId());
    notification.setMessage(request.getMessage());
    notification.setStatus(NotificationStatus.SENT);
    notification.setSentTime(LocalDateTime.now());
    notificationRepository.save(notification);
    
    // 6. 发送通知 (可以是邮件、短信、站内信等)
    notificationService.sendAssignmentNotification(notification);
    
    return ResponseEntity.ok(new AssignmentResponse("派单成功", notification.getNotificationId()));
}
```

### 4.3 操作人员接单功能

#### 4.3.1 我的任务界面
```html
<!-- 操作人员任务列表 -->
<div class="card">
    <div class="card-header">
        <h5><i class="fas fa-inbox me-2"></i>我的派单任务</h5>
    </div>
    <div class="card-body">
        <div class="table-responsive">
            <table class="table">
                <thead>
                    <tr>
                        <th>订单号</th>
                        <th>服务类型</th>
                        <th>派单人</th>
                        <th>内部协议</th>
                        <th>派单时间</th>
                        <th>状态</th>
                        <th>操作</th>
                    </tr>
                </thead>
                <tbody id="myAssignmentTasks">
                    <!-- 动态加载 -->
                </tbody>
            </table>
        </div>
    </div>
</div>
```

#### 4.3.2 协议确认对话框
```html
<!-- 协议确认模态框 -->
<div class="modal fade" id="protocolConfirmModal" tabindex="-1">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">
                    <i class="fas fa-handshake me-2"></i>确认内部协议
                </h5>
            </div>
            <div class="modal-body">
                <div class="row">
                    <div class="col-md-6">
                        <h6 class="text-primary">协议信息</h6>
                        <table class="table table-sm">
                            <tr><td>协议编号:</td><td id="protocolId"></td></tr>
                            <tr><td>协议名称:</td><td id="protocolName"></td></tr>
                            <tr><td>销售部门:</td><td id="salesDept"></td></tr>
                            <tr><td>操作部门:</td><td id="operationDept"></td></tr>
                        </table>
                    </div>
                    <div class="col-md-6">
                        <h6 class="text-primary">分润规则</h6>
                        <table class="table table-sm">
                            <tr><td>基本佣金率:</td><td id="baseCommission"></td></tr>
                            <tr><td>绩效奖金率:</td><td id="performanceBonus"></td></tr>
                            <tr><td>生效日期:</td><td id="effectiveDate"></td></tr>
                            <tr><td>过期日期:</td><td id="expiryDate"></td></tr>
                        </table>
                    </div>
                </div>
                
                <div class="alert alert-info mt-3">
                    <i class="fas fa-info-circle me-2"></i>
                    <strong>确认须知:</strong> 点击确认后，您将成为此服务的负责人，并同意按照上述协议条款执行服务和进行分润。
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">取消</button>
                <button type="button" class="btn btn-success" onclick="confirmProtocolAndAcceptTask()">
                    <i class="fas fa-check me-2"></i>确认协议并接单
                </button>
            </div>
        </div>
    </div>
</div>
```

#### 4.3.3 接单确认逻辑
```java
@PostMapping("/services/{serviceId}/accept")
public ResponseEntity<AcceptanceResponse> acceptServiceTask(
    @PathVariable Long serviceId,
    @RequestBody TaskAcceptanceRequest request) {
    
    // 1. 验证操作人员权限
    OrderService orderService = orderServiceRepository.findById(serviceId)
        .orElseThrow(() -> new EntityNotFoundException("服务任务不存在"));
    
    if (!orderService.getOperationStaffId().equals(request.getOperationStaffId())) {
        throw new UnauthorizedException("您没有权限接受此任务");
    }
    
    if (!ServiceStatus.ASSIGNED.equals(orderService.getStatus())) {
        throw new InvalidStatusException("任务状态不允许接单");
    }
    
    // 2. 记录协议确认
    orderService.setStatus(ServiceStatus.PROTOCOL_CONFIRMED);
    orderService.setProtocolConfirmedTime(LocalDateTime.now());
    orderService.setProtocolConfirmedBy(request.getOperationStaffId());
    orderService.setAcceptanceNotes(request.getNotes());
    orderServiceRepository.save(orderService);
    
    // 3. 更新通知状态
    ServiceAssignmentNotification notification = notificationRepository
        .findByServiceIdAndToStaffId(serviceId, request.getOperationStaffId());
    if (notification != null) {
        notification.setStatus(NotificationStatus.CONFIRMED);
        notification.setConfirmedTime(LocalDateTime.now());
        notificationRepository.save(notification);
    }
    
    // 4. 触发分润数据准备
    profitSharingService.prepareDataForService(orderService);
    
    // 5. 发送确认通知给派单客服
    notificationService.sendAcceptanceConfirmation(orderService, request.getOperationStaffId());
    
    return ResponseEntity.ok(new AcceptanceResponse("接单成功", orderService.getStatus()));
}
```

### 4.4 权限管理增强

#### 4.4.1 基于角色的功能控制
```java
@Component
public class PermissionValidator {
    
    // 验证订单创建权限
    public boolean canCreateOrder(String staffId) {
        Staff staff = staffRepository.findById(staffId).orElse(null);
        return staff != null && RoleType.CUSTOMER_SERVICE.equals(staff.getRoleType());
    }
    
    // 验证派单权限
    public boolean canAssignService(String orderId, String staffId) {
        Order order = orderRepository.findById(orderId).orElse(null);
        return order != null && staffId.equals(order.getResponsibleStaffId());
    }
    
    // 验证接单权限
    public boolean canAcceptTask(Long serviceId, String staffId) {
        OrderService service = orderServiceRepository.findById(serviceId).orElse(null);
        return service != null && 
               staffId.equals(service.getOperationStaffId()) &&
               ServiceStatus.ASSIGNED.equals(service.getStatus());
    }
}
```

#### 4.4.2 前端权限控制
```javascript
// 基于用户角色显示/隐藏功能
function initializeUserInterface() {
    const userRole = getCurrentUserRole();
    
    if (userRole === 'CUSTOMER_SERVICE') {
        // 客服界面
        showElements([
            '#newOrderButton',
            '#serviceAssignmentSection',
            '#orderTrackingSection'
        ]);
        hideElements([
            '#myTasksSection'
        ]);
    } else if (userRole === 'OPERATION') {
        // 操作人员界面
        showElements([
            '#myTasksSection',
            '#taskExecutionSection'
        ]);
        hideElements([
            '#newOrderButton',
            '#serviceAssignmentSection'
        ]);
    }
}
```

## 5. 实施计划

### 阶段一: 数据模型和基础功能 (1-2天)
1. ✅ 分析现有系统架构
2. 🔧 增强User角色和OrderService状态
3. 🔧 创建ServiceAssignmentNotification实体
4. 🔧 更新数据库Schema

### 阶段二: 客服接单功能 (2-3天)  
1. 🔧 增强订单创建接口
2. 🔧 实现服务选择界面
3. 🔧 完善业务类型约束逻辑
4. 🔧 测试客服接单流程

### 阶段三: 派单功能开发 (3-4天)
1. 🔧 实现协议匹配算法
2. 🔧 开发派单界面和API
3. 🔧 创建通知发送机制
4. 🔧 测试完整派单流程

### 阶段四: 接单确认功能 (2-3天)
1. 🔧 开发操作人员任务界面  
2. 🔧 实现协议确认对话框
3. 🔧 完善接单确认逻辑
4. 🔧 集成分润数据准备

### 阶段五: 集成测试和优化 (2天)
1. 🔧 完整业务流程测试
2. 🔧 权限控制验证
3. 🔧 性能优化和错误处理
4. 🔧 用户界面优化

## 6. 技术要点

### 6.1 状态机设计
```
订单状态流转:
DRAFT → CONFIRMED → IN_PROGRESS → COMPLETED

服务状态流转: 
PENDING → ASSIGNED → PROTOCOL_CONFIRMED → IN_PROGRESS → COMPLETED
```

### 6.2 事务管理
- 订单创建+服务创建: 单一事务
- 服务派单+通知发送: 分离事务(通知失败不影响派单)
- 协议确认+分润准备: 单一事务

### 6.3 异常处理策略
- 权限验证: 返回401/403状态码
- 数据验证: 返回400状态码并提供详细错误信息  
- 业务规则: 返回409状态码并说明冲突原因
- 系统错误: 返回500状态码并记录日志

### 6.4 性能优化
- 协议匹配: 建立复合索引 (sales_dept + operation_dept + service_code)
- 任务查询: 建立复合索引 (operation_staff_id + status)
- 通知查询: 建立复合索引 (to_staff_id + status + sent_time)

## 7. 测试方案

### 7.1 单元测试
- 协议匹配算法测试
- 权限验证逻辑测试  
- 状态转换规则测试

### 7.2 集成测试
- 完整接派单流程测试
- 多用户并发操作测试
- 跨部门协作测试

### 7.3 用户验收测试
- 客服操作流程测试
- 操作人员接单测试
- 主管监控功能测试

这个实施方案在现有OneOrder系统基础上，完整实现了您需要的接派单业务流程，保持了数据一致性和业务逻辑的完整性。