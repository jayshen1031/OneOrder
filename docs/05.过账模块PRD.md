# OneOrder过账模块产品需求文档(PRD)

## 📋 文档信息
- **版本**: v1.0  
- **创建日期**: 2025-09-15
- **创建者**: Claude Code Assistant
- **项目**: OneOrder货代订单管理与财务清分系统
- **模块**: 过账处理模块

## 🎯 模块概述

### 业务背景
过账模块是OneOrder系统中在内部交易初步清分完成基础上，进一步针对特殊过账规则进行处理的高级模块。过账可以理解为一种特殊的借抬头行为，但其交易两端均为内部法人体，主要用于满足特定的资金路由和合规要求。

### 核心价值
1. **资金路由管控**: 按照特定路径进行资金流转，满足合规要求
2. **过账费用管理**: 合理收取过账服务费，优化资金成本
3. **轧差结算支持**: 减少重复交易，提高资金效率
4. **差异账单处理**: 支持清分结果的增量更新和变更管理

## 📊 核心业务原则

### 处理原则
1. **后置处理**: 在资金流清分完成后进行过账处理
2. **法人体维度**: 只涉及法人属性，不涉及部门属性
3. **路由规则驱动**: 基于配置的路由规则自动调整资金流向
4. **轧差可选**: 支持收付分开和轧差两种处理模式

### 核心计算公式
```
过账留存金额 = 过账金额 × 留存比例 or 固定金额
实际转付金额 = 收到金额 - 过账留存金额
轧差后金额 = |法人A付法人B - 法人B付法人A|
```

## 🔧 详细业务流程

### 1. 过账触发条件

#### 1.1 前置条件
- 内部交易已完成初步清分
- 星式结算结果已生成
- 内部交易明细表已生成成对交易

#### 1.2 过账处理时机
- 在星式结算完成后自动触发
- 支持手动触发过账处理
- 可配置是否启用过账功能

### 2. 资金路由规则判定

#### 2.1 路由规则结构

**规则字段定义**
| 字段名称 | 字段说明 | 数据类型 | 必填 | 示例 |
|---------|---------|----------|------|------|
| 付款法人公司 | 原始付款方法人 | 下拉选择 | 是 | A公司 |
| 收款法人公司 | 原始收款方法人 | 下拉选择 | 是 | B公司 |
| 币种 | 交易币种 | 下拉选择 | 是 | USD |
| 路由公司1 | 第一个过账法人 | 下拉选择 | 是 | C公司 |
| 路由公司2 | 第二个过账法人(可选) | 下拉选择 | 否 | D公司 |

#### 2.2 路由规则匹配

**匹配逻辑**
```
IF (付款法人 = A公司 AND 收款法人 = B公司 AND 币种 = USD) 
THEN 应用路由规则: A → C → D → B
```

**默认直接收付**
- 如果没有匹配的路由规则，法人体之间可以直接收付
- 资金路径呈网状结构，无需过账处理

#### 2.3 路由规则优先级

**匹配优先级**
1. 精确匹配：付款法人+收款法人+币种完全匹配
2. 通配符匹配：支持法人或币种的通配符规则
3. 默认规则：无匹配规则时的默认处理方式

### 3. 过账处理详例

#### 3.1 单路由公司示例

**业务场景**
- 原始交易：A公司付B公司1000美元
- 路由规则：A→B，USD，路由公司C
- C公司过账留存：1%

**过账处理**
```
步骤1: 匹配路由规则
A付B 1000美元 → 匹配规则(A,B,USD,C)

步骤2: 调整资金流向
原流向: A → B (1000美元)
新流向: A → C → B

步骤3: 计算过账留存
C收A: 1000美元
C留存: 1000 × 1% = 10美元  
C付B: 1000 - 10 = 990美元

步骤4: 生成过账交易
A付C: 1000美元
C收A: 1000美元
C付B: 990美元
B收C: 990美元
```

#### 3.2 双路由公司示例

**业务场景**  
- 原始交易：A公司付B公司1000美元
- 路由规则：A→B，USD，路由公司C和D
- C公司过账留存：1%，D公司过账留存：1%

**过账处理**
```
步骤1: 匹配路由规则
A付B 1000美元 → 匹配规则(A,B,USD,C,D)

步骤2: 调整资金流向  
原流向: A → B (1000美元)
新流向: A → C → D → B

步骤3: 计算过账留存
A付C: 1000美元
C收A: 1000美元，留存1% = 10美元，付D: 990美元
D收C: 990美元，留存1% = 9.9美元，付B: 980.1美元
B收D: 980.1美元

步骤4: 生成过账交易序列
A付C: 1000美元 (A收入减少1000)
C收A: 1000美元，C付D: 990美元 (C净收入10)
D收C: 990美元，D付B: 980.1美元 (D净收入9.9)  
B收D: 980.1美元 (B收入980.1)
```

### 4. 过账留存规则

#### 4.1 留存计算模式

**比例留存模式**
```
留存金额 = 过账金额 × 留存比例
转付金额 = 过账金额 - 留存金额
```

**固定金额留存模式**
```
留存金额 = 固定金额
转付金额 = 过账金额 - 固定金额
```

#### 4.2 业务法人体豁免规则

**豁免条件**
- 如果过账公司在业务中作为客服ID对应的法人公司
- 如果过账公司在业务中作为操作ID对应的法人公司
- 正常业务利润留存已满足税务要求

**豁免处理**
```
IF (过账法人 = 客服ID法人 OR 过账法人 = 操作ID法人) 
THEN 过账留存 = 0
ELSE 过账留存 = 按配置规则计算
```

### 5. 轧差结算处理

#### 5.1 重复过账识别

**重复过账场景**
```
业务场景: A付B，B付C
路由规则: A付B经由D，B付C经由D

处理前:
A付B → A付D，D付B  
B付C → B付D，D付C

识别结果: 存在D付B和B付D的重复交易
```

#### 5.2 轧差处理规则配置

**规则字段**
| 字段名称 | 字段说明 | 数据类型 | 必填 | 示例 |
|---------|---------|----------|------|------|
| 过账法人体 | 发生重复交易的过账法人 | 下拉选择 | 是 | D公司 |
| 对象法人体 | 与过账法人发生重复交易的法人 | 下拉选择 | 是 | B公司 |
| 处理模式 | 轧差或收付分开 | 单选 | 是 | 轧差 |

#### 5.3 轧差计算示例

**收付分开模式**
```
D付B: 900元
B付D: 800元
处理结果: 保留两笔交易，不进行合并
```

**轧差模式**
```
D付B: 900元  
B付D: 800元
轧差计算: 900 - 800 = 100元
处理结果: D付B 100元 (取消B付D)
```

### 6. 差异账单处理

#### 6.1 差异场景识别

**差异产生原因**
- 外部收付账单发生变化
- 分润规则进行了调整
- 过账规则配置发生变更
- 借抬头留存规则调整

#### 6.2 差异计算逻辑

**差异计算公式**
```
新账单 = 原有账单 + 差异账单
差异账单 = 新生成结果 - 原有结果
```

**差异账单示例**
```
原有结果: A付B 1000元
新生成结果: A付B 1200元  
差异账单: A付B 200元

最终账单 = 原有账单(1000) + 差异账单(200) = 1200元
```

#### 6.3 差异处理策略

**增量更新模式**
- 只生成变化部分的差异账单
- 保留原有账单记录
- 支持差异账单的追溯和审计

**全量替换模式**
- 完全替换原有清分结果
- 适用于大幅调整的场景
- 保留历史版本记录

## 🎨 界面设计需求

### 1. 过账处理主界面

#### 1.1 界面布局
```
+----------------------------------------------------------+
| OneOrder - 过账处理                  [执行过账] [导出]    |
+----------------------------------------------------------+
| 订单信息区域                                               |
| 订单号: HCBD20250915001  |  过账状态: 已完成            |
| 原始交易笔数: 6          |  过账后交易笔数: 12           |
+----------------------------------------------------------+
| 路由规则匹配结果                              [展开/收起] |
| +------------------------------------------------------+ |
| | 原始交易 | 匹配规则 | 路由路径 | 过账费用 | 状态    | |
| | A→B 1000 | 规则001  | A→C→D→B  | C:10,D:9.9| 已处理 | |
| +------------------------------------------------------+ |
+----------------------------------------------------------+
| 过账交易明细                                              |
| [原始交易] [过账交易] [轧差结果] 切换标签                  |
| 详细交易明细表                                            |
+----------------------------------------------------------+
```

#### 1.2 交互设计
- **路由规则查看**: 点击匹配规则可查看具体的路由规则配置
- **交易流程图**: 可视化展示过账前后的资金流向变化
- **差异对比**: 支持查看过账前后的交易差异
- **轧差分析**: 展示轧差处理的详细计算过程

### 2. 路由规则配置界面

#### 2.1 规则配置表
```
+--------------------------------------------------------+
| 路由规则配置                           [+ 添加规则]    |
+--------------------------------------------------------+
| 规则ID | 付款法人 | 收款法人 | 币种 | 路由公司1 | 路由公司2 | 状态 |
|--------|----------|----------|------|-----------|-----------|------|
| R001   | A公司    | B公司    | USD  | C公司     | D公司     | 启用 |
| R002   | A公司    | *        | CNY  | E公司     | -         | 启用 |
| R003   | *        | B公司    | EUR  | F公司     | G公司     | 禁用 |
+--------------------------------------------------------+
```

#### 2.2 规则编辑弹窗
```
+--------------------------------------------+
| 编辑路由规则                    [×]        |
+--------------------------------------------+
| 规则名称: [_____________________]          |
| 付款法人: [下拉选择: A公司]                |
| 收款法人: [下拉选择: B公司]                |
| 币种:     [下拉选择: USD]                  |
+--------------------------------------------+
| 路由配置                                   |
| 路由公司1: [下拉选择: C公司] [必填]        |
| 过账留存: [○比例] [○固定] 值:[____]        |
| 路由公司2: [下拉选择: D公司] [可选]        |
| 过账留存: [○比例] [○固定] 值:[____]        |
+--------------------------------------------+
| 规则优先级: [____] 生效日期: [____]        |
|                    [取消] [保存]          |
+--------------------------------------------+
```

### 3. 过账交易流程图

#### 3.1 流程可视化
```
+--------------------------------------------------------+
| 过账处理流程图                                          |
+--------------------------------------------------------+
| 原始交易:                                               |
| A公司 ----1000美元----> B公司                          |
+--------------------------------------------------------+
| 过账后交易:                                             |
| A公司 ----1000美元----> C公司 ----990美元----> D公司    |
|                         (留存10)      ----980.1美元--> B公司 |
|                                       (留存9.9)        |
+--------------------------------------------------------+
| 过账汇总:                                               |
| • A公司支出: 1000美元                                   |
| • B公司收入: 980.1美元                                  |
| • C公司留存: 10美元                                     |
| • D公司留存: 9.9美元                                    |
| • 总过账费用: 19.9美元                                  |
+--------------------------------------------------------+
```

### 4. 轧差处理界面

#### 4.1 轧差前后对比
```
+--------------------------------------------------------+
| 轧差处理分析                                            |
+--------------------------------------------------------+
| 轧差前交易:                                             |
| D公司 → B公司: 900.00元                                |
| B公司 → D公司: 800.00元                                |
+--------------------------------------------------------+
| 轧差计算:                                               |
| 轧差金额 = |900.00 - 800.00| = 100.00元               |
| 轧差方向 = D公司 → B公司                               |
+--------------------------------------------------------+
| 轧差后交易:                                             |
| D公司 → B公司: 100.00元                                |
| (已取消: B公司 → D公司: 800.00元)                      |
+--------------------------------------------------------+
| 轧差效果:                                               |
| • 减少交易笔数: 2笔 → 1笔                              |
| • 减少资金周转: 1600.00元 → 100.00元                   |
| • 提升效率: 93.75%                                     |
+--------------------------------------------------------+
```

## 🔒 数据模型设计

### 1. 资金路由规则表
```sql
CREATE TABLE fund_routing_rules (
    id BIGSERIAL PRIMARY KEY,
    rule_name VARCHAR(100) NOT NULL,        -- 规则名称
    payer_entity_id VARCHAR(50) NOT NULL,   -- 付款法人公司
    payee_entity_id VARCHAR(50) NOT NULL,   -- 收款法人公司
    currency VARCHAR(10) NOT NULL,          -- 币种
    routing_entity_1_id VARCHAR(50) NOT NULL, -- 路由公司1
    routing_entity_2_id VARCHAR(50),        -- 路由公司2(可选)
    priority INTEGER DEFAULT 1,             -- 优先级
    effective_date DATE NOT NULL,           -- 生效日期
    expiry_date DATE,                       -- 失效日期
    status VARCHAR(20) DEFAULT 'ACTIVE',    -- 状态: ACTIVE/INACTIVE
    created_by VARCHAR(50) NOT NULL,
    created_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_by VARCHAR(50),
    updated_time TIMESTAMP,
    
    INDEX idx_routing_match (payer_entity_id, payee_entity_id, currency),
    INDEX idx_priority_effective (priority DESC, effective_date DESC),
    INDEX idx_routing_entities (routing_entity_1_id, routing_entity_2_id)
);
```

### 2. 过账留存规则表
```sql
CREATE TABLE routing_retention_rules (
    id BIGSERIAL PRIMARY KEY,
    routing_entity_id VARCHAR(50) NOT NULL, -- 过账法人ID
    retention_type VARCHAR(20) NOT NULL,    -- 留存类型: PERCENTAGE/FIXED
    retention_value DECIMAL(15,4) NOT NULL, -- 留存值(比例或固定金额)
    min_amount DECIMAL(15,2),               -- 最小过账金额
    max_amount DECIMAL(15,2),               -- 最大过账金额
    currency VARCHAR(10),                   -- 适用币种(NULL表示全部)
    business_exemption BOOLEAN DEFAULT FALSE, -- 业务法人豁免
    effective_date DATE NOT NULL,           -- 生效日期
    expiry_date DATE,                       -- 失效日期
    status VARCHAR(20) DEFAULT 'ACTIVE',    -- 状态: ACTIVE/INACTIVE
    created_by VARCHAR(50) NOT NULL,
    created_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    INDEX idx_routing_entity (routing_entity_id),
    INDEX idx_effective_date (effective_date)
);
```

### 3. 轧差处理规则表
```sql
CREATE TABLE netting_processing_rules (
    id BIGSERIAL PRIMARY KEY,
    routing_entity_id VARCHAR(50) NOT NULL, -- 过账法人体
    counterpart_entity_id VARCHAR(50) NOT NULL, -- 对象法人体
    processing_mode VARCHAR(20) NOT NULL,   -- 处理模式: NETTING/SEPARATE
    min_netting_amount DECIMAL(15,2),       -- 最小轧差金额
    currency VARCHAR(10),                   -- 适用币种
    effective_date DATE NOT NULL,           -- 生效日期
    expiry_date DATE,                       -- 失效日期
    status VARCHAR(20) DEFAULT 'ACTIVE',    -- 状态: ACTIVE/INACTIVE
    created_by VARCHAR(50) NOT NULL,
    created_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    UNIQUE (routing_entity_id, counterpart_entity_id, currency),
    INDEX idx_entity_pair (routing_entity_id, counterpart_entity_id)
);
```

### 4. 过账处理结果表
```sql
CREATE TABLE routing_processing_results (
    id BIGSERIAL PRIMARY KEY,
    order_id VARCHAR(50) NOT NULL,
    original_transaction_id BIGINT NOT NULL, -- 原始内部交易ID
    routing_rule_id BIGINT,                 -- 应用的路由规则ID
    routing_path VARCHAR(500) NOT NULL,     -- 路由路径(如: A→C→D→B)
    original_amount DECIMAL(15,2) NOT NULL, -- 原始交易金额
    total_routing_fee DECIMAL(15,2) DEFAULT 0, -- 总过账费用
    final_received_amount DECIMAL(15,2) NOT NULL, -- 最终到账金额
    routing_entity_count INTEGER DEFAULT 0,  -- 过账法人数量
    generated_transaction_count INTEGER DEFAULT 0, -- 生成交易笔数
    processing_status VARCHAR(20) DEFAULT 'COMPLETED', -- 处理状态
    processing_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    FOREIGN KEY (order_id) REFERENCES orders(order_id),
    FOREIGN KEY (original_transaction_id) REFERENCES internal_transactions(id),
    FOREIGN KEY (routing_rule_id) REFERENCES fund_routing_rules(id),
    INDEX idx_order_routing (order_id),
    INDEX idx_original_transaction (original_transaction_id)
);
```

### 5. 过账交易明细表
```sql
CREATE TABLE routing_transaction_details (
    id BIGSERIAL PRIMARY KEY,
    order_id VARCHAR(50) NOT NULL,
    routing_result_id BIGINT NOT NULL,      -- 过账处理结果ID
    transaction_pair_id VARCHAR(50) NOT NULL, -- 交易对ID
    sequence_number INTEGER NOT NULL,        -- 在路由中的序号
    routing_entity_id VARCHAR(50),          -- 过账法人ID(如果是过账交易)
    our_entity_id VARCHAR(50) NOT NULL,     -- 我方法人ID
    counterpart_entity_id VARCHAR(50) NOT NULL, -- 对方法人ID
    transaction_type VARCHAR(10) NOT NULL,  -- 交易类型: RECEIVABLE/PAYABLE
    amount DECIMAL(15,2) NOT NULL,          -- 交易金额
    retention_amount DECIMAL(15,2) DEFAULT 0, -- 过账留存金额
    currency VARCHAR(10) DEFAULT 'CNY',     -- 币种
    fee_code VARCHAR(50) DEFAULT 'INTERNAL_FREIGHT', -- 费用科目
    transaction_category VARCHAR(20) DEFAULT 'ROUTING', -- 交易类别: ROUTING/ORIGINAL
    generated_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    FOREIGN KEY (order_id) REFERENCES orders(order_id),
    FOREIGN KEY (routing_result_id) REFERENCES routing_processing_results(id),
    INDEX idx_order_routing_result (order_id, routing_result_id),
    INDEX idx_transaction_pair (transaction_pair_id),
    INDEX idx_routing_entity (routing_entity_id)
);
```

### 6. 轧差处理结果表
```sql
CREATE TABLE netting_processing_results (
    id BIGSERIAL PRIMARY KEY,
    order_id VARCHAR(50) NOT NULL,
    entity_a_id VARCHAR(50) NOT NULL,       -- 法人A
    entity_b_id VARCHAR(50) NOT NULL,       -- 法人B
    amount_a_to_b DECIMAL(15,2) DEFAULT 0,  -- A付B金额
    amount_b_to_a DECIMAL(15,2) DEFAULT 0,  -- B付A金额
    netting_amount DECIMAL(15,2) NOT NULL,  -- 轧差金额
    netting_direction VARCHAR(10) NOT NULL, -- 轧差方向: A_TO_B/B_TO_A
    processing_mode VARCHAR(20) NOT NULL,   -- 处理模式: NETTING/SEPARATE
    original_transaction_count INTEGER DEFAULT 0, -- 原始交易笔数
    final_transaction_count INTEGER DEFAULT 0,    -- 最终交易笔数
    efficiency_improvement DECIMAL(5,4),    -- 效率提升比例
    processing_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    FOREIGN KEY (order_id) REFERENCES orders(order_id),
    INDEX idx_order_netting (order_id),
    INDEX idx_entity_pair (entity_a_id, entity_b_id)
);
```

### 7. 差异账单表
```sql
CREATE TABLE clearing_difference_bills (
    id BIGSERIAL PRIMARY KEY,
    order_id VARCHAR(50) NOT NULL,
    original_version INTEGER NOT NULL,      -- 原始版本号
    new_version INTEGER NOT NULL,           -- 新版本号
    entity_id VARCHAR(50) NOT NULL,         -- 法人ID
    counterpart_entity_id VARCHAR(50) NOT NULL, -- 对方法人ID
    transaction_type VARCHAR(10) NOT NULL,  -- 交易类型: RECEIVABLE/PAYABLE
    original_amount DECIMAL(15,2) DEFAULT 0, -- 原始金额
    new_amount DECIMAL(15,2) DEFAULT 0,     -- 新金额
    difference_amount DECIMAL(15,2) NOT NULL, -- 差异金额
    difference_type VARCHAR(20) NOT NULL,   -- 差异类型: INCREASE/DECREASE/NEW/CANCEL
    change_reason VARCHAR(200),             -- 变更原因
    generated_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    FOREIGN KEY (order_id) REFERENCES orders(order_id),
    INDEX idx_order_version (order_id, new_version),
    INDEX idx_difference_type (difference_type),
    INDEX idx_entity_pair (entity_id, counterpart_entity_id)
);
```

## 🔧 API接口设计

### 1. 过账处理API

#### 1.1 执行过账处理
```http
POST /api/routing/process
Content-Type: application/json

{
    "orderId": "HCBD20250915001",
    "enableRouting": true,
    "enableNetting": true,
    "forceReprocess": false
}

Response:
{
    "code": 200,
    "message": "过账处理完成",
    "data": {
        "orderId": "HCBD20250915001",
        "processingTime": "2025-09-15T10:30:00",
        "originalTransactionCount": 6,
        "routingTransactionCount": 12,
        "nettingTransactionCount": 8,
        "totalRoutingFee": 19.90,
        "efficiencyImprovement": 0.3333
    }
}
```

#### 1.2 查询过账结果
```http
GET /api/routing/results/{orderId}

Response:
{
    "code": 200,
    "data": {
        "orderInfo": {
            "orderId": "HCBD20250915001",
            "processingStatus": "COMPLETED",
            "processingTime": "2025-09-15T10:30:00"
        },
        "routingResults": [
            {
                "originalTransactionId": 123,
                "routingRuleId": 1,
                "routingPath": "A→C→D→B",
                "originalAmount": 1000.00,
                "totalRoutingFee": 19.90,
                "finalReceivedAmount": 980.10
            }
        ],
        "nettingResults": [
            {
                "entityAId": "ENTITY_D",
                "entityBId": "ENTITY_B", 
                "amountAToB": 900.00,
                "amountBToA": 800.00,
                "nettingAmount": 100.00,
                "nettingDirection": "A_TO_B"
            }
        ],
        "finalTransactions": [
            {
                "ourEntityId": "ENTITY_A",
                "counterpartEntityId": "ENTITY_C",
                "transactionType": "PAYABLE",
                "amount": 1000.00,
                "transactionCategory": "ROUTING"
            }
        ]
    }
}
```

### 2. 路由规则管理API

#### 2.1 查询匹配的路由规则
```http
GET /api/routing/rules/match
?payerEntityId=ENTITY_A
&payeeEntityId=ENTITY_B
&currency=USD

Response:
{
    "code": 200,
    "data": {
        "ruleId": 1,
        "ruleName": "A-B美元路由规则",
        "payerEntityId": "ENTITY_A",
        "payeeEntityId": "ENTITY_B", 
        "currency": "USD",
        "routingEntity1Id": "ENTITY_C",
        "routingEntity2Id": "ENTITY_D",
        "priority": 10
    }
}
```

#### 2.2 创建路由规则
```http
POST /api/routing/rules
Content-Type: application/json

{
    "ruleName": "A-B美元路由规则",
    "payerEntityId": "ENTITY_A",
    "payeeEntityId": "ENTITY_B",
    "currency": "USD", 
    "routingEntity1Id": "ENTITY_C",
    "routingEntity2Id": "ENTITY_D",
    "priority": 10,
    "effectiveDate": "2025-01-01"
}

Response:
{
    "code": 200,
    "message": "路由规则创建成功",
    "data": {
        "ruleId": 1,
        "status": "ACTIVE"
    }
}
```

### 3. 差异账单API

#### 3.1 生成差异账单
```http
POST /api/routing/difference-bills/generate
Content-Type: application/json

{
    "orderId": "HCBD20250915001",
    "originalVersion": 1,
    "newVersion": 2,
    "changeReason": "分润规则调整"
}

Response:
{
    "code": 200,
    "message": "差异账单生成完成",
    "data": {
        "orderId": "HCBD20250915001",
        "differenceCount": 3,
        "totalDifferenceAmount": 150.00,
        "majorChanges": [
            {
                "entityId": "ENTITY_A",
                "transactionType": "PAYABLE",
                "differenceAmount": 100.00,
                "differenceType": "INCREASE"
            }
        ]
    }
}
```

## 🚀 业务规则引擎

### 1. 路由规则匹配引擎

```java
public class RoutingRuleEngine {
    
    // 规则1: 查找匹配的路由规则
    public Optional<FundRoutingRule> findMatchingRule(
            String payerEntityId,
            String payeeEntityId, 
            String currency) {
        
        List<FundRoutingRule> candidates = routingRuleRepository
            .findActiveRulesByDate(LocalDate.now());
            
        return candidates.stream()
            .filter(rule -> matchesExactly(rule, payerEntityId, payeeEntityId, currency))
            .max(Comparator.comparing(FundRoutingRule::getPriority));
    }
    
    // 规则2: 生成路由交易路径
    public List<RoutingTransactionDetail> generateRoutingPath(
            FundRoutingRule rule,
            BigDecimal originalAmount,
            String currency) {
        
        List<RoutingTransactionDetail> transactions = new ArrayList<>();
        String transactionPairId = generateTransactionPairId();
        
        // 第一段: 原付款方 → 路由公司1
        BigDecimal currentAmount = originalAmount;
        transactions.addAll(createTransactionPair(
            rule.getPayerEntityId(), 
            rule.getRoutingEntity1Id(),
            currentAmount, transactionPairId + "_1"));
        
        // 计算路由公司1留存
        BigDecimal retention1 = calculateRoutingRetention(
            rule.getRoutingEntity1Id(), currentAmount);
        currentAmount = currentAmount.subtract(retention1);
        
        // 第二段: 路由公司1 → 路由公司2(如果存在)
        if (rule.getRoutingEntity2Id() != null) {
            transactions.addAll(createTransactionPair(
                rule.getRoutingEntity1Id(),
                rule.getRoutingEntity2Id(), 
                currentAmount, transactionPairId + "_2"));
                
            BigDecimal retention2 = calculateRoutingRetention(
                rule.getRoutingEntity2Id(), currentAmount);
            currentAmount = currentAmount.subtract(retention2);
        }
        
        // 最后一段: 最后路由公司 → 原收款方
        String finalRoutingEntity = rule.getRoutingEntity2Id() != null ? 
            rule.getRoutingEntity2Id() : rule.getRoutingEntity1Id();
        transactions.addAll(createTransactionPair(
            finalRoutingEntity,
            rule.getPayeeEntityId(),
            currentAmount, transactionPairId + "_final"));
            
        return transactions;
    }
}
```

### 2. 轧差处理引擎

```java
public class NettingEngine {
    
    // 识别重复交易
    public List<NettingCandidate> identifyNettingCandidates(List<RoutingTransactionDetail> transactions) {
        
        Map<String, List<RoutingTransactionDetail>> entityPairMap = transactions.stream()
            .collect(Collectors.groupingBy(this::generateEntityPairKey));
            
        return entityPairMap.entrySet().stream()
            .filter(entry -> entry.getValue().size() >= 2)
            .map(this::createNettingCandidate)
            .collect(Collectors.toList());
    }
    
    // 执行轧差处理
    public NettingProcessingResult processNetting(
            NettingCandidate candidate,
            NettingProcessingRule rule) {
        
        BigDecimal amountAToB = calculateDirectionalAmount(candidate, Direction.A_TO_B);
        BigDecimal amountBToA = calculateDirectionalAmount(candidate, Direction.B_TO_A);
        
        if (ProcessingMode.NETTING.equals(rule.getProcessingMode())) {
            // 轧差模式
            BigDecimal nettingAmount = amountAToB.subtract(amountBToA).abs();
            Direction nettingDirection = amountAToB.compareTo(amountBToA) >= 0 ? 
                Direction.A_TO_B : Direction.B_TO_A;
                
            return NettingProcessingResult.builder()
                .entityAId(candidate.getEntityAId())
                .entityBId(candidate.getEntityBId())
                .amountAToB(amountAToB)
                .amountBToA(amountBToA)
                .nettingAmount(nettingAmount)
                .nettingDirection(nettingDirection)
                .processingMode(ProcessingMode.NETTING)
                .build();
        } else {
            // 收付分开模式
            return NettingProcessingResult.builder()
                .entityAId(candidate.getEntityAId())
                .entityBId(candidate.getEntityBId())
                .amountAToB(amountAToB)
                .amountBToA(amountBToA)
                .processingMode(ProcessingMode.SEPARATE)
                .build();
        }
    }
}
```

### 3. 差异账单生成引擎

```java
public class DifferenceBillEngine {
    
    // 生成差异账单
    public List<ClearingDifferenceBill> generateDifferenceBills(
            String orderId,
            List<InternalTransaction> originalTransactions,
            List<RoutingTransactionDetail> newTransactions) {
        
        List<ClearingDifferenceBill> differenceBills = new ArrayList<>();
        
        // 构建原始交易Map
        Map<String, BigDecimal> originalAmountMap = buildTransactionAmountMap(originalTransactions);
        
        // 构建新交易Map  
        Map<String, BigDecimal> newAmountMap = buildTransactionAmountMap(newTransactions);
        
        // 计算差异
        Set<String> allKeys = new HashSet<>();
        allKeys.addAll(originalAmountMap.keySet());
        allKeys.addAll(newAmountMap.keySet());
        
        for (String key : allKeys) {
            BigDecimal originalAmount = originalAmountMap.getOrDefault(key, BigDecimal.ZERO);
            BigDecimal newAmount = newAmountMap.getOrDefault(key, BigDecimal.ZERO);
            BigDecimal difference = newAmount.subtract(originalAmount);
            
            if (difference.compareTo(BigDecimal.ZERO) != 0) {
                differenceBills.add(createDifferenceBill(
                    orderId, key, originalAmount, newAmount, difference));
            }
        }
        
        return differenceBills;
    }
    
    private String buildTransactionKey(String entityId, String counterpartId, String type) {
        return entityId + "_" + counterpartId + "_" + type;
    }
    
    private ClearingDifferenceBill createDifferenceBill(
            String orderId, 
            String transactionKey,
            BigDecimal originalAmount,
            BigDecimal newAmount, 
            BigDecimal difference) {
        
        String[] keyParts = transactionKey.split("_");
        DifferenceType diffType = determineDifferenceType(originalAmount, newAmount);
        
        return ClearingDifferenceBill.builder()
            .orderId(orderId)
            .entityId(keyParts[0])
            .counterpartEntityId(keyParts[1])
            .transactionType(keyParts[2])
            .originalAmount(originalAmount)
            .newAmount(newAmount)
            .differenceAmount(difference)
            .differenceType(diffType)
            .build();
    }
}
```

## 📋 验收标准

### 功能验收
- ✅ 路由规则匹配准确，支持精确匹配和通配符匹配
- ✅ 过账路径生成正确，支持单路由和双路由公司
- ✅ 过账留存计算准确，支持比例留存和固定留存
- ✅ 业务法人体豁免规则正确执行
- ✅ 轧差处理功能正常，支持轧差和收付分开两种模式
- ✅ 差异账单生成准确，支持增量更新模式
- ✅ 过账交易成对生成，只带法人属性

### 数据准确性验收
- ✅ 过账前后资金总额平衡
- ✅ 路由过账费用计算准确
- ✅ 轧差计算结果正确
- ✅ 差异账单金额准确
- ✅ 交易路径完整无遗漏

### 性能验收
- ✅ 单订单过账处理时间 < 8秒
- ✅ 支持50+路由规则的复杂匹配
- ✅ 轧差处理响应时间 < 3秒
- ✅ 差异账单生成时间 < 5秒

## 🎊 业务价值

### 合规风险控制
1. **资金路由管控**: 按照合规要求进行特定路径的资金流转
2. **过账费用透明**: 清晰记录过账环节的费用成本
3. **审计轨迹完整**: 完整的过账处理和差异变更记录
4. **合规报告支持**: 为监管报告提供详细的资金流向数据

### 资金效率优化
1. **轧差结算**: 减少重复交易，降低资金周转成本
2. **路径优化**: 通过合理的路由设计降低整体过账成本
3. **集中管理**: 统一的过账规则管理和执行
4. **差异管控**: 精确的差异识别和处理机制

### 系统集成支持
1. **清分流程完整**: 完成从录费到最终清分的完整闭环
2. **版本管理**: 支持清分结果的版本控制和历史追溯
3. **增量更新**: 高效的差异账单处理机制
4. **数据一致性**: 确保过账处理后的数据完整性和准确性

---

## 附录

### A. 路由规则配置示例
```json
{
  "ruleName": "A-B美元过账规则",
  "payerEntityId": "ENTITY_A",
  "payeeEntityId": "ENTITY_B",
  "currency": "USD",
  "routingEntity1Id": "ENTITY_C",
  "routingEntity2Id": "ENTITY_D",
  "priority": 10
}
```

### B. 过账留存规则示例
```json
{
  "routingEntityId": "ENTITY_C",
  "retentionType": "PERCENTAGE",
  "retentionValue": 0.01,
  "businessExemption": false,
  "effectiveDate": "2025-01-01"
}
```

### C. 轧差处理规则示例
```json
{
  "routingEntityId": "ENTITY_D",
  "counterpartEntityId": "ENTITY_B", 
  "processingMode": "NETTING",
  "minNettingAmount": 100.00,
  "currency": "CNY"
}
```

### D. 错误码定义
- RT001: 路由规则配置错误
- RT002: 过账留存规则不存在
- RT003: 轧差处理规则冲突
- RT004: 过账路径生成失败
- RT005: 差异账单计算错误

---
*最后更新: 2025-09-15*  
*文档版本: v1.0*  
*项目: OneOrder过账模块*